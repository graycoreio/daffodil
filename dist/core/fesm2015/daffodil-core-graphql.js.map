{"version":3,"file":"daffodil-core-graphql.js","sources":["ng://@daffodil/core/graphql/fragments/build-fragment-name-spread.ts","ng://@daffodil/core/graphql/fragments/build-fragment-definition.ts","ng://@daffodil/core/graphql/apollo/queued-apollo.service.ts"],"sourcesContent":["import { DocumentNode, FragmentDefinitionNode } from 'graphql'\n\nconst getFragmentNames = (fragment: DocumentNode) =>\n  fragment.definitions.filter(def =>\n    def.kind === 'FragmentDefinition'\n  ).map(def =>\n    (def as FragmentDefinitionNode).name.value\n  )\n\n/**\n * Builds a list of fragment names present inside the specified GraphQL document nodes.\n * Returns an empty array if no fragments have been defined or if null is passed.\n * @param fragments The created fragments.\n */\nconst daffGetFragmentNames = (...fragments: DocumentNode[]): string[] =>\n  fragments.reduce((acc, fragment) => acc.concat(getFragmentNames(fragment)), [])\n\n/**\n * Builds a string of fragment names that can be interpolated into a GraphQL query.\n * Each name is separated by a newline character: '\\n'.\n * If an empty array is passed, an empty string is returned.\n * @param fragments A list of GraphQL documents that contain fragments.\n */\nexport const daffBuildFragmentNameSpread = (...fragments: DocumentNode[]): string =>\n  daffGetFragmentNames(...fragments).reduce((acc, name) => acc.concat(`...${name}\\n`), '')\n","import { DocumentNode } from 'graphql'\n\n/**\n * Builds a string of fragment definitions that can be interpolated into a GraphQL query.\n * Each definition is separated by a newline character: '\\n'.\n * @param documents A list of GraphQL documents that should only contain fragments.\n */\nexport const daffBuildFragmentDefinition = (...documents: DocumentNode[]): string =>\n  documents.reduce((acc, fragment) => acc.concat(`${fragment.loc.source.body}\\n`), '')\n","import { Injectable } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { R } from 'apollo-angular/types';\nimport { MutationOptions } from 'apollo-client';\nimport { FetchResult } from 'apollo-link';\nimport { Observable, Subscriber, Subscription } from 'rxjs';\n\n/**\n * A service that will queue mutate calls to Apollo.\n * It will not send subsequent mutate requests until the previous one has been completed.\n * This is useful for avoiding race conditions on the backend.\n * This should be used alongside Apollo.\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class DaffQueuedApollo {\n  queue: Function[] = [];\n\n  constructor(\n    private apollo: Apollo\n  ) {}\n\n  /**\n   * Queue up a mutate request.\n   * The request will not actually be queued until the returned observable is subscribed.\n   * If the queue is empty, the request will be sent when it enters the queue.\n   * Otherwise, it will be sent when it reaches the front of the queue.\n   * The observable will complete after it emits once.\n   * @param options Mutation options.\n   */\n  mutate<T, V = R>(options: MutationOptions<T, V>): Observable<FetchResult<T>> {\n    return new Observable(subscriber => this.addRequestToQueue(subscriber, this.apollo.mutate(options)))\n  }\n\n  private addRequestToQueue(subscriber: Subscriber<any>, request: Observable<any>): void {\n    this.queue.push(() => {\n      const sub = request.subscribe(\n        response => {\n          // emit the outer observable\n          subscriber.next(response);\n          subscriber.complete();\n\n          this.finishRequestSubscription(sub);\n        },\n        error => {\n          subscriber.error(error)\n          this.finishRequestSubscription(sub);\n        },\n        () => {\n          subscriber.complete()\n          this.finishRequestSubscription(sub);\n        }\n      )\n    });\n\n    // start the queue if previously empty\n    if (this.queue.length === 1) this.queue[0]();\n  }\n\n  private finishRequestSubscription(requestSubscription: Subscription): void {\n    requestSubscription.unsubscribe();\n\n    // process queue\n    this.queue.shift();\n    // TODO: optional chaining\n    if (this.queue[0]) this.queue[0]();\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;MAEM,gBAAgB;;;;AAAG,CAAC,QAAsB,KAC9C,QAAQ,CAAC,WAAW,CAAC,MAAM;;;;AAAC,GAAG,IAC7B,GAAG,CAAC,IAAI,KAAK,oBAAoB,EAClC,CAAC,GAAG;;;;AAAC,GAAG,IACP,oBAAC,GAAG,IAA4B,IAAI,CAAC,KAAK,EAC3C,CAAA;;;;;;;;;;;;;;MAOG,oBAAoB;;;;AAAG,CAAC,GAAG,SAAyB,KACxD,SAAS,CAAC,MAAM;;;;;AAAC,CAAC,GAAG,EAAE,QAAQ,KAAK,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,GAAE,EAAE,CAAC,CAAA;;;;;;;;;;;;;;;;AAQjF,MAAa,2BAA2B;;;;AAAG,CAAC,GAAG,SAAyB,KACtE,oBAAoB,CAAC,GAAG,SAAS,CAAC,CAAC,MAAM;;;;;AAAC,CAAC,GAAG,EAAE,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,GAAE,EAAE,CAAC,CAAA;;;;;;;;;;;;ACjB1F,MAAa,2BAA2B;;;;AAAG,CAAC,GAAG,SAAyB,KACtE,SAAS,CAAC,MAAM;;;;;AAAC,CAAC,GAAG,EAAE,QAAQ,KAAK,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,GAAE,EAAE,CAAC,CAAA;;;;;;;;;;;ACRtF;;;;;;AAgBA,MAAa,gBAAgB;;;;IAG3B,YACU,MAAc;QAAd,WAAM,GAAN,MAAM,CAAQ;QAHxB,UAAK,GAAe,EAAE,CAAC;KAInB;;;;;;;;;;;IAUJ,MAAM,CAAW,OAA8B;QAC7C,OAAO,IAAI,UAAU;;;;QAAC,UAAU,IAAI,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAC,CAAA;KACrG;;;;;;;IAEO,iBAAiB,CAAC,UAA2B,EAAE,OAAwB;QAC7E,IAAI,CAAC,KAAK,CAAC,IAAI;;;QAAC;;kBACR,GAAG,GAAG,OAAO,CAAC,SAAS;;;;YAC3B,QAAQ;;gBAEN,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1B,UAAU,CAAC,QAAQ,EAAE,CAAC;gBAEtB,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC;aACrC;;;;YACD,KAAK;gBACH,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;gBACvB,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC;aACrC;;;YACD;gBACE,UAAU,CAAC,QAAQ,EAAE,CAAA;gBACrB,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC;aACrC,EACF;SACF,EAAC,CAAC;;QAGH,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;YAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;KAC9C;;;;;;IAEO,yBAAyB,CAAC,mBAAiC;QACjE,mBAAmB,CAAC,WAAW,EAAE,CAAC;;QAGlC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;;QAEnB,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;KACpC;;;YAtDF,UAAU,SAAC;gBACV,UAAU,EAAE,MAAM;aACnB;;;;YAdQ,MAAM;;;;;IAgBb,iCAAuB;;;;;IAGrB,kCAAsB;;;;;;;;;;;;;;;;;;;;;;;;;"}