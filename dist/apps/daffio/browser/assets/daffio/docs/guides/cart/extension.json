{
  "id": "guides/cart/extension",
  "title": "Extension",
  "contents": "\n<div class=\"content\">\n<h1 id=\"extension\">Extension</h1>\n<ul>\n<li><a href=\"#extension\">Extension</a><ul>\n<li><a href=\"#custom-drivers\">Custom Drivers</a></li>\n<li><a href=\"#generic-models\">Generic Models</a></li>\n<li><a href=\"#extensible-graphql-fragments\">Extensible GraphQL Fragments</a><ul>\n<li><a href=\"#magento\">Magento</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>@daffodil/cart</code> provides a number of extension mechanisms so that it can be customized to fit specific needs.</p>\n<h2 id=\"custom-drivers\">Custom Drivers</h2>\n<p>If the packaged Daffodil drivers don&#39;t satisfy the required use cases, they can be overriden by providing custom drivers. Create a service that implements the interface corresponding to the driver in question.</p>\n<p>If custom behavior is not needed for all driver methods, unimplemented methods can be delegated to the original driver. The following example demonstrates overriding the <code>create</code> method of the <code>DaffCartDriver</code> while using Magento.</p>\n<pre><code class=\"language-typescript\">import {\n  DaffCartDriver,\n  DaffMagentoCartService\n} from &#39;@daffodil/cart&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;\n})\nexport class CustomMagentoCartService implements DaffCartServiceInterface {\n  constructor(\n    private cartDriver: DaffMagentoCartService,\n  ) {}\n\n  get(cartId: string): Observable&lt;DaffCart&gt; {\n    return this.cartDriver.get(cartId);\n  }\n\n  create(): Observable&lt;{id: string}&gt; {\n    // custom behavior\n  }\n\n  addToCart(productId: string, qty: number): Observable&lt;DaffCart&gt; {\n    return this.cartDriver.addToCart(productId, qty);\n  }\n\n  clear(cartId: string): Observable&lt;Partial&lt;DaffCart&gt;&gt; {\n    return this.cartDriver.clear(cartId);\n    }\n}\n\n@NgModule({\n  ...,\n  providers: [\n    {\n      provide: DaffCartDriver,\n      useExisting: CustomMagentoCartService\n    }\n  ]\n})\nclass AppModule {}</code></pre>\n<h2 id=\"generic-models\">Generic Models</h2>\n<p>All Daffodil layers can operate on generic extensions of vanilla Daffodil models. Custom models can therefore be used while retaining type safety. The following example illustrates customizing the cart model with the cart facade.</p>\n<pre><code class=\"language-typescript\">import {\n  DaffCartFacade,\n  DaffCart\n} from &#39;@daffodil/cart&#39;;\n\ninterface CustomCart extends DaffCart {\n  customField: string;\n}\n\n@Component({})\nclass CartComponent implements OnInit {\n  cart$: Observable&lt;CustomCart&gt;;\n\n  constructor(private cartFacade: DaffCartFacade&lt;CustomCart&gt;) {}\n\n  ngOnInit() {\n    // this.cartFacade.cart$ is of type CustomCart\n    this.cart$ = this.cartFacade.cart$;\n  }\n}</code></pre>\n<h2 id=\"extensible-graphql-fragments\">Extensible GraphQL Fragments</h2>\n<p>Arbitrary additional fields can be requested on the cart object. Inject a GraphQL document node containing fragments on the platform&#39;s cart type to define extra fields.</p>\n<p>Only drivers that use GraphQL support extensible fragments because fragments are specific to GraphQL. The following cart drivers support extensible fragments:</p>\n<ul>\n<li>Magento</li>\n</ul>\n<h3 id=\"magento\">Magento</h3>\n<p>Provide the <code>DAFF_CART_MAGENTO_EXTRA_CART_FRAGMENTS</code> to query additional fields on a Magento cart query. This applies to all of the driver calls that return a <code>DaffCart</code>, which is most of them.</p>\n<p>The additional fields are present on the untyped <code>extra_attributes</code> field.</p>\n<p>The following example demonstrates providing a GraphQL document using the <code>graphql-tag</code> library.</p>\n<pre><code class=\"language-typescript\">import gql from &#39;graphql-tag&#39;;\nimport {\n  DAFF_CART_MAGENTO_EXTRA_CART_FRAGMENTS,\n  DaffCartFacade,\n  DaffCartLoad,\n  DaffCart\n} from &#39;@daffodil/cart&#39;;\n\nconst extraCartFragment = gql`\n  fragment ExtraCartFields on Cart {\n    field1 {\n      amount\n    }\n    shipping_addresses {\n      field2 {\n        value\n      }\n    }\n  }\n`;\n\n@NgModule({\n  ...,\n  providers: [\n    {\n      provide: DAFF_CART_MAGENTO_EXTRA_CART_FRAGMENTS,\n      useValue: extraCartFragment,\n      multi: true\n    }\n  ]\n})\nclass AppModule {}\n\n@Component({})\nclass CartComponent implements OnInit {\n  cart$: Observable&lt;DaffCart&gt;;\n  field1$: Observable&lt;{amount: number}&gt;;\n  field2$: Observable&lt;{value: string}&gt;;\n\n  constructor(private cartFacade: DaffCartFacade) {}\n\n  ngOnInit() {\n    this.loadCart();\n    this.cart$ = this.cartFacade.cart$;\n    this.field1$ = this.cart$.pipe(\n      map(cart =&gt; cart.extra_attributes?.field1)\n    );\n    this.field2$ = this.cart$.pipe(\n      map(cart =&gt; cart.extra_attributes?.shipping_addresses?.[0]?.field2)\n    );\n  }\n\n  private loadCart() {\n    this.cartFacade.dispatch(new DaffCartLoad());\n  }\n}</code></pre>\n<blockquote>\n<p>An extra cart fragment is defined and provided for the <code>DAFF_CART_MAGENTO_EXTRA_CART_FRAGMENTS</code> injection token. The <code>CartComponent</code> then loads the cart on initialization, which will query the cart and include the extra injected cart fields in the request. The component maps the extra fields from <code>cart.extra_attributes</code> to local fields.</p>\n</blockquote>\n\n</div>\n"
}