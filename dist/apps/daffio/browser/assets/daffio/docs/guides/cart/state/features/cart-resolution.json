{
  "id": "guides/cart/state/features/cart-resolution",
  "title": "Cart Resolution",
  "contents": "\n<div class=\"content\">\n<h1 id=\"cart-resolution\">Cart Resolution</h1>\n<p>This tutorial will walk you through Daffodil&#39;s Cart Resolution process which is responsible for resolving a user&#39;s cart upon application initialization. This behavior is chiefly managed by the <code>DaffResolvedCartGuard</code>.</p>\n<h2 id=\"supported-scenarios\">Supported Scenarios</h2>\n<p>At the moment, the following scenarios are handled by the <code>DaffResolvedCartGuard</code> <strong>for guest users only</strong>.</p>\n<blockquote>\n<p>Note that currently, carts for authenticated users are not supported.</p>\n</blockquote>\n<ul>\n<li>Generating a new cart when a user visits the application for the very first time.</li>\n<li>Retrieving a previously existing cart for a user upon page reload.</li>\n<li>Generating a new cart for a user when their prior cart isn&#39;t found (e.g., after expiry).</li>\n<li>Skipping cart resolution during server-side rendering.</li>\n<li>Upon a resolution failure, bailing out and navigating somewhere outside the scope of a cart resolution (e.g. your Ecommerce Service&#39;s API is down).</li>\n</ul>\n<h2 id=\"usage\">Usage</h2>\n<p>Assuming that you&#39;re already using the <code>DaffCartStateModule</code> and have previously selected a <a href=\"../../drivers.md\">driver</a> for <code>@daffodil/cart</code>, you can simply add the guard to your route&#39;s <code>canActivate</code> and the guard will handle the rest.</p>\n<pre><code class=\"language-typescript\">import { Routes, RouterModule } from &#39;@angular/router&#39;;\nimport { HelloComponent } from &#39;./hello.component&#39;;\nimport { DaffResolvedCartGuard } from &#39;@daffodil/cart/state&#39;;\nimport { DaffCartInMemoryDriverModule } from &#39;@daffodil/cart/driver/in-memory&#39;;\nexport const appRoutes: [\n   {\n      path: &#39;&#39;,\n      component: HelloComponent,\n      canActivate: [DaffResolvedCartGuard],\n   }\n]\n\n@NgModule({\n  imports: [\n    //DaffCartInMemoryDriverModule.forRoot(),\n    DaffCartStateModule.forRoot(),\n    RouterModule.forRoot(appRoutes),\n  ],\n  exports: [RouterModule],\n})\nexport class AppModule {}</code></pre>\n<p>Upon adding the code, load up the route and take a look at the Network Requests in your browser. You should see at least one request to your ecommerce systems&#39;s cart endpoint that attempts resolution.</p>\n<h2 id=\"configuration\">Configuration</h2>\n<p>You can configure the route to which the <code>DaffResolvedCartGuard</code> navigates when an error occurs during resolution. See the <a href=\"./configuration.md\">configuration guide</a> and the <code>resolution</code> key of <code>DaffCartStateConfiguration</code> for more information.</p>\n<h2 id=\"gotchas\">Gotchas</h2>\n<h3 id=\"guard-ordering\">Guard Ordering</h3>\n<p>The guard&#39;s return is observable, and as such, when paired with other guards it won&#39;t necessarily complete in the order you expect, be sure to be careful about your guard ordering.</p>\n<p>For example, Angular provides no guarantee that either of these guards runs before the other.</p>\n<pre><code class=\"language-ts\">{\n  ...,\n  canActivate: [DaffResolvedCartGuard, SomeOtherGuard]\n}</code></pre>\n<p>If you need the guarantee, you can nest the guards.</p>\n<pre><code class=\"language-ts\">{\n  ...,\n  canActivate: [DaffResolvedCartGuard],\n  children: [\n    {\n      ...\n      canActivate: [SomeOtherGuard]\n    }\n  ]\n}</code></pre>\n\n</div>\n"
}