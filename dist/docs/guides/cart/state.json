{
  "id": "guides/cart/state",
  "title": "State",
  "contents": "\n<div class=\"content\">\n<h1 id=\"state\">State</h1>\n<ul>\n<li><a href=\"#state\">State</a><ul>\n<li><a href=\"#setting-up-appmodule\">Setting up <code>AppModule</code></a></li>\n<li><a href=\"#using-the-facade\">Using the Facade</a></li>\n<li><a href=\"#accessing-state-with-selectors\">Accessing State with Selectors</a></li>\n</ul>\n</li>\n</ul>\n<p><code>@daffodil/cart</code> provides a fully featured state library to streamline the management of an application&#39;s state as well as driver interaction.</p>\n<p>The facade is an abstraction that provides all the functionality needed for standard use. It is the recommended way to interact with the Daffodil state layer.</p>\n<h2 id=\"setting-up-appmodule\">Setting up <code>AppModule</code></h2>\n<p>To get started, import the <code>DaffCartModule</code> in <code>AppModule</code>. Next, import <code>StoreModule.forRoot({})</code>, which will be relevant later on when using the redux and state management features of the cart module.</p>\n<pre><code class=\"language-typescript\">@ngModule({\n  imports:[\n    StoreModule.forRoot({}),\n    DaffCartModule\n  ]\n})\nexport class AppModule {}</code></pre>\n<h2 id=\"using-the-facade\">Using the Facade</h2>\n<p>The <code>DaffCartModule</code> provides a <code>DaffCartFacade</code> that wraps the complexities of the state library into one place. This facade will handle updating the user&#39;s cart and can also be used to build UI with behaviors common to a cart.</p>\n<p>To inject the facade inside a component, include an instance of <code>DaffCartFacade</code> in the component&#39;s constructor.</p>\n<pre><code class=\"language-typescript\">@Component({})\nexport class CartComponent {\n  constructor(public cartFacade: DaffCartFacade) {}\n}</code></pre>\n<p>Once the <code>DaffCartFacade</code> has been set up in the component, it can now be used to manage a user&#39;s cart. To perform operations on the cart, pass actions to the <code>DaffCartFacade#dispatch</code> method. When carts are created using the <code>DaffCartCreate</code> action, Daffodil will save the cart ID in local storage and automatically pass it to the driver layer for future operations. Various cart properties and a list of errors are available on the cart facade as observable streams.</p>\n<blockquote>\n<p>Note that the storage mechanism can be configured. See <a href=\"../../core/guides/advanced/storage.md#environment-specific-storage-services\">the storage guide</a> for more details.</p>\n</blockquote>\n<p>Additionally, the Daffodil cart facade provides three different loading states for each section of the cart. <code>mutating$</code> tracks when an update to a cart property is occurring. <code>resolving$</code> tracks when new data is being fetched but no updates are taking place. <code>loading$</code> emits <code>true</code> when either <code>mutating$</code> or <code>resolving$</code> is <code>true</code>. There is also overall <code>featureLoading$</code>, <code>featureMutating$</code>, and <code>featureResolving$</code> streams to track loading for any section of the cart. These can be used to enhance the application&#39;s UI.</p>\n<p>The following example illustrates a component used to display and manage a cart&#39;s items.</p>\n<pre><code class=\"language-typescript\">import {\n  DaffCartItemAdd,\n  DaffCartItemList,\n  DaffCartItemInput,\n  DaffCartItemInputType,\n  DaffCartFacade,\n  DaffCartItem\n} from &#39;@daffodil/cart&#39;;\n\nexport class CartItemComponent implements OnInit {\n  items$: Observable&lt;DaffCartItem[]&gt;;\n  errors$: Observable&lt;string[]&gt;;\n  loading$: Observable&lt;boolean&gt;;\n\n  constructor(public cartFacade: DaffCartFacade) {}\n\n  ngOnInit() {\n    this.items$ = this.cartFacade.items$;\n    this.errors$ = this.cartFacade.itemErrors$;\n    this.loading$ = this.cartFacade.itemLoading$;\n\n    // load the cart items\n    this.cartFacade.dispatch(new DaffCartItemList())\n  }\n\n  addSimpleItem(productId: string, qty: number) {\n    const input: DaffCartItemInput = {\n      type: DaffCartItemInputType.Simple,\n      productId,\n      qty\n    };\n    this.cartFacade.dispatch(new DaffCartItemAdd(input));\n  }\n}</code></pre>\n<blockquote>\n<p>In this example, three observable streams are assigned from <code>cartFacade</code>. Then when <code>addSimpleItem</code> is called, the <code>cartFacade</code>&#39;s  <code>dispatch</code> function is called with the appropriately formed input. The input data is then sent off to the backend and the three observable streams are updated when a response is received.</p>\n</blockquote>\n<h2 id=\"accessing-state-with-selectors\">Accessing State with Selectors</h2>\n<p>Accessing state with the facade is recommended but for greater flexibility the redux store&#39;s state can be directly accessed with Daffodil&#39;s selectors.</p>\n<p>To properly maintain memoization of selectors that are compatible with generic models, Daffodil selectors are hidden behind an exported getter function. This function returns an object that contains the selectors.</p>\n<p>The following example also showcases a component used to display and manage a cart&#39;s items but without using the facade.</p>\n<pre><code class=\"language-typescript\">import {\n  DaffCartItemAdd,\n  DaffCartItemList,\n  DaffCartItemInput,\n  DaffCartItemInputType,\n  DaffCartItem,\n  getDaffCartSelectors\n} from &#39;@daffodil/cart&#39;;\n\nexport class CartItemComponent implements OnInit {\n  items$: Observable&lt;DaffCartItem[]&gt;;\n  errors$: Observable&lt;string[]&gt;;\n  loading$: Observable&lt;boolean&gt;;\n\n  constructor(public store: Store&lt;any&gt;) {}\n\n  ngOnInit() {\n    const {\n      selectCartItems,\n      selectItemErrors,\n      selectItemLoading\n    } = getDaffCartSelectors();\n\n    this.items$ = this.store.pipe(select(selectCartItems));\n    this.errors$ = this.store.pipe(select(selectItemErrors));\n    this.loading$ = this.store.pipe(select(selectItemLoading));\n\n    // load the cart items\n    this.store.dispatch(new DaffCartItemList())\n  }\n\n  addSimpleItem(productId: string, qty: number) {\n    const input: DaffCartItemInput = {\n      type: DaffCartItemInputType.Simple,\n      productId,\n      qty\n    };\n    this.store.dispatch(new DaffCartItemAdd(input));\n  }\n}</code></pre>\n<!-- TODO: add dependency injectable reducers guide once we implement it -->\n<!-- TODO: add dependency injectable actions for effects guide once we implement it -->\n\n</div>\n"
}